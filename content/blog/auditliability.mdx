---
title: Auditor Liability
description: How do you define Auditor Liability and its importance
image: /images/blog/audit.png
date: "2024-7-31"
authors:
  - cryptopolicydao
---

<Callout>What is Audit Liability and why is it important?</Callout>

#### Understanding the nuances between developer intent and code execution is critical in establishing clear Audit Liability standards in web3.

The expectation of an smart contract audit is that every error is understood and corrected. Though, when dealing with
programming languages, fully comprehending all potential actions of a smart contract can be challenging. Developers aim
to ensure their contracts operate as intended and are free from vulnerabilities that could result in loss of funds or
unintended outcomes. However, smart contracts operate based on the defined logic principles and syntax of the programming language
used, meaning certain operations are strictly bound by these rules.

Auditors must go beyond merely identifying potential errors, they need to grasp the developer's intended user journey
and expectations of the app to ensure the smart contracts behave as expected. For example, in the programming language Solidity,
a common issue is integer overflow and underflow, and an integer overflow might be a deliberate
feature in some scenarios, like resetting a counter, rather than a vulnerability. Misinterpreting these intentions can
lead to misguided corrections and unintended actions. Therefore, a thorough understanding and clear communication between developers and auditors
are essential for accurate and effective audits and especially for establishing Auditor Liability.

Auditor Liability begins with the auditing scope and ends with the implementation of the corrections, so establishing
the parameters that define it is necessary in order to understand if an audit is thorough, comprehensive, and utilizing up to-date smart contract
best practices. There should be a standard understanding of what is occuring during an audit and what the level of security expectations should
be.

#### Integer Overflow

Integer overflow occurs when a calculation exceeds the maximum value that can be stored in a variable.
In Solidity, for example, the `uint8` data type can store values from 0 to 255, so if you add 1 to 255,
it overflows and wraps around to 0 leading to an error, or possible exploit.

```solidity
uint8 max = 255;
uint8 result = max + 1;
```

However, in actuality, this is what is happening:

```solidity
result = 255 + 1 = 0
```

#### Integer underflow

Integer underflow occurs when a calculation goes below the minimum value that can be stored in a variable.
Using the same uint8 data type in Solidity, if you subtract 1 from 0, it underflows and wraps around to 255.

```solidity
uint8 min = 0;
uint8 result = min - 1;
```

As well, In this scenario, since uint8 cannot store negative numbers,
subtracting 1 from 0 causes it to wrap around to the highest value, which is 255.

```solidity
result = 0 - 1 = 255
```

#### Example with the SafeMath OpenZeppelin import

When programming with Solidity, developers can utilize the OpenZeppelin SafeMath import standard and utilize smart contract best practices that are
open-source and tested by multiple smart contract experts. This means that any operation that overflows or underflows will not succeed
and will revert the transaction. The main point of this is to illustrate the difference of what is intended to happen when the
developer codes the smart contract and what is actually happening using the logic and syntax of a particular smart contract language.

In Vyper, on the other hand, integer overflow and underflow are inherently prevented as the language includes built-in checks that revert
transactions on such operations. This design choice simplifies development and enhances security, but it still necessitates
a comprehensive audit to ensure there are no other logical errors or overlooked vulnerabilities. By leveraging the strengths
of each language and adhering to best practices, developers can better manage audit liabilities and improve the robustness
of their smart contracts.

```silidity
using SafeMath for uint8;

uint8 max = 255;
uint8 result = max.add(1); // This will revert the transaction

uint8 min = 0;
uint8 result = min.sub(1); // This will revert the transaction
```

#### Comparison of programming languages

| Language          | Integer Overflow/Underflow Vulnerability | Mitigation Method                          |
| ----------------- | ---------------------------------------- | ------------------------------------------ |
| Solidity          | Yes (pre-0.8.0) / No (0.8.0+)            | Library (SafeMath) / Syntax (0.8.0+)       |
| Vyper             | No                                       | Syntax                                     |
| Rust              | Yes                                      | Syntax (Debug mode)/Library (Release mode) |
| C++               | Yes                                      | Manual / Library / Compiler options        |
| Tezos (Michelson) | No                                       | Syntax                                     |
| Move (Libra)      | No                                       | Syntax                                     |

#### Auditor Liability

The difference between a developer's intended code and the actual implementation can create significant vulnerabilities,
highlighting the necessity for auditors to fully grasp the developer's vision. This is crucial in smart contract auditing
as both parties should rely on the audit with almost equal weight.

#### Example Logic Tree aligned with Expected User Journey

```solidity
Mock Kingdom Smart Contract
│
├─ Initialize Game (Constructor)
│  ├─ Set owner
│  │  ├─ Asset Layer Risk: None
│  │  └─ Administrative Risk: Centralization (Known since Ethereum's inception, 2015)
│  │     ├─ Mitigation 1: Implement multi-sig wallet (Introduced by BitGo in 2013)
│  │     │  └─ Resulting Risk: Coordination failure
│  │     │     └─ Potential Outcome: Delayed decision-making
│  │     └─ Mitigation 2: Implement DAO governance (First major DAO: The DAO, April 30, 2016)
│  │        └─ Resulting Risk: Voter apathy
│  │           └─ Potential Outcome: Minority control
│  │
│  ├─ Initialize player stats (use SafeMath)
│  │  ├─ Asset Layer Risk: Integer overflow/underflow (BEC Token hack, April 22, 2018)
│  │  │  ├─ Mitigation 1: Use OpenZeppelin's SafeMath library (SafeMath became a library: April 19, 2017)
│  │  │  │  └─ Resulting Risk: Increased gas costs
│  │  │  │     └─ Potential Outcome: Higher transaction fees
│  │  │  └─ Mitigation 2: Use Solidity 0.8.x built-in overflow checks (Released: December 16, 2020)
│  │  │     └─ Resulting Risk: Compatibility issues with older compilers
│  │  │        └─ Potential Outcome: Limited portability
│  │  └─ Administrative Risk: None
│  │
│  └─ Mint initial game tokens (check for overflow)
│     ├─ Asset Layer Risk: Token supply manipulation (Highlighted by SmartBillions hack, October 2017)
│     │  ├─ Mitigation 1: Implement supply cap (Used in Bitcoin protocol since 2009)
│     │  │  └─ Resulting Risk: Inflexibility in token economics
│     │  │     └─ Potential Outcome: Difficulty in adjusting to game growth
│     │  └─ Mitigation 2: Implement minting limits per time period (Used in MakerDAO, December 2017)
│     │     └─ Resulting Risk: Complex tracking mechanism
│     │        └─ Potential Outcome: Increased contract complexity
│     └─ Administrative Risk: Unauthorized minting
│        └─ Mitigation: Implement role-based access control (OpenZeppelin, 2018)
│           └─ Resulting Risk: Centralization of minting authority
│              └─ Potential Outcome: Single point of failure for token issuance
│
├─ Join Game (Function)
│  ├─ Check if player exists
│  │  ├─ Yes: Revert transaction
│  │  │  ├─ Asset Layer Risk: Denial of Service (DoS) (GovernMental Ponzi scheme, April 2016)
│  │  │  │  ├─ Mitigation 1: Implement cooldown period (CryptoKitties, November 28, 2017)
│  │  │  │  │  └─ Resulting Risk: Legitimate players locked out
│  │  │  │  │     └─ Potential Outcome: Reduced player onboarding
│  │  │  │  └─ Mitigation 2: Implement gas-efficient existence check (EIP-1052, May 2018)
│  │  │  │     └─ Resulting Risk: Increased storage costs
│  │  │  │        └─ Potential Outcome: Higher deployment/operation costs
│  │  │  └─ Administrative Risk: None
│  │  │
│  │  └─ No: Create new player
│  │     ├─ Asset Layer Risk: Resource exploitation (Multiple game hacks, e.g., Fomo3D, July 2018)
│  │     │  ├─ Mitigation 1: Implement progressive resource allocation (Axie Infinity, 2018)
│  │     │  │  └─ Resulting Risk: Complex onboarding process
│  │     │  │     └─ Potential Outcome: New player confusion
│  │     │  └─ Mitigation 2: Implement initial resource limits (Common in DeFi since Compound, September 2018)
│  │     │     └─ Resulting Risk: Initial gameplay limitations
│  │     │        └─ Potential Outcome: Reduced early-game engagement
│  │     └─ Administrative Risk: None
│  │
│  └─ Emit NewPlayerEvent
│     ├─ Asset Layer Risk: Event spam (Ethereum network congestion, CryptoKitties, December 2017)
│     │  ├─ Mitigation 1: Implement event throttling (EIP-1699 proposed, October 2018)
│     │  │  └─ Resulting Risk: Delayed event propagation
│     │  │     └─ Potential Outcome: Inconsistent front-end updates
│     │  └─ Mitigation 2: Batch event emissions (Uniswap V2, May 2020)
│     │     └─ Resulting Risk: Increased transaction size
│     │        └─ Potential Outcome: Higher gas costs for users
│     └─ Administrative Risk: None

```

Sources

1.
2.
3.
